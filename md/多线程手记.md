# 多线程

## java内存模型

### java栈 

- 每个线程有自己的栈资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其它线程是访问不了的
- 栈还用来存放线程的调用栈帧
  - 调用 `test()` 方法时，就会把当前方法的一些信息封装为栈帧压入到栈顶，栈顶的栈帧就是活跃的 `test` 方法。当执行到 `say()` 方法时就会在栈顶新加一个关于 `say()` 方法的栈帧，这时候 `say()` 方法所在栈帧就是活跃栈帧。当 `say()` 方法执行完毕后，`say()` 方法所在的栈顶帧就会出栈，这时候栈顶活跃帧就是 `test` 方法的了

### 堆

- 堆（heap）是一个进程中最大的一块内存，是进程创建时候创建的，堆是被进程中的所有线程共享的。堆里面主要存放使用`new` 操作创建的对象实例

### 方法区

- 方法区（method area）用来存放 JVM 加载的类信息、常量、静态变量、全局变量等信息，也是线程共享的。

### 程序计数器

- 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
- PC寄存器用来**存储指向下一条指令的地址**，也就是将要执行的指令代码。由**执行引擎读取下一条指令**

## java多线程工作原理

- 当前线程首先从主内存拷贝共享变量到自己的工作内存
- 然后对工作内存里的变量进行处理
- 处理完后更新变量值到主内存

#### Volatile与Synchronized

**Synchronized**

> 线程结束后同步共享变量

**Volatile**

> 实时同步共享变量

​    那么一般什么时候才使用 volatile 关键字修饰变量呢？

- 当写入变量值不依赖变量的当前值。因为如果依赖当前值则是获取-计算-写入操作，这三步操作不是原子性的，而 volatile 不保证原子性。
- 读写变量值的时候没有进行加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为 volatile。